(********************************************************************
 * Programm: Druckregelung
 * Autor: Markthaler
 * Erstellt: 30.03.2022
 * Info: Druckregelung für die Dampfseite (l_i=1) und die Prozessgasseite (l_i=2)
 ********************************************************************)


PROGRAM _INIT
	//Initialisierung der PID-Regelparameter und Rampenparameter (individuell für jede Druckregelung)
	l_i:=1; //Dampf
	l_r_pid_var[l_i,0] := 100;
	l_r_pid_var[l_i,1] := 14.4;
	l_r_pid_var[l_i,2] := 1;
	l_r_pid_var[l_i,3] := 0.346;
	l_r_ramp_var[l_i,0] := 0.05;
	l_r_ramp_var[l_i,1] := 0.03;
	l_r_ramp_var[l_i,2] := 0.0;
	l_r_ramp_var[l_i,3] := 10.0;
	l_i:=2; //Prozessgas
	l_r_pid_var[l_i,0] := 140.09;
	l_r_pid_var[l_i,1] := 14.4;
	l_r_pid_var[l_i,2] := 3.46;
	l_r_pid_var[l_i,3] := 0.346;
	l_r_ramp_var[l_i,0] := 0.05;
	l_r_ramp_var[l_i,1] := 0.03;
	l_r_ramp_var[l_i,2] := 0.0;
	l_r_ramp_var[l_i,3] := 10.0;
	l_i:=3; //Dampf: Kontrollierte Ventilöffnung
	l_r_ramp_var[l_i,0] := 15;	//Öffnen der Ventile von 0% -> 100% Öffnungsgrad in 6.6s
	l_r_ramp_var[l_i,1] := 15;
	l_r_ramp_var[l_i,2] := 0.0;
	l_r_ramp_var[l_i,3] := 100.0;
	l_i:=4; //Prozessgas: Kontrollierte Ventilöffnung
	l_r_ramp_var[l_i,0] := 15;	//Öffnen der Ventile von 0% -> 100% Öffnungsgrad in 6.6s
	l_r_ramp_var[l_i,1] := 15;
	l_r_ramp_var[l_i,2] := 0.0;
	l_r_ramp_var[l_i,3] := 100.0;

	LOOP l_i = 1 TO 2 DO	
		//Starwerte für die Grenzen des Öffnungsgrads der Ventilstellung
		g_rv_RV[l_i].r_open_min := 0;  		// entspricht Ventil zu 0% geöffnet
		g_rv_RV[l_i].r_open_max := 100;		// entspricht Ventil zu 100% geöffnet
		
		l_r_pid_var[l_i,4] := g_rv_RV[l_i].r_open_min;			//Angepasst an Ventilstellung [MinOut = 0 -> Ventil zu 0% geöffnet]
		l_r_pid_var[l_i,5] := g_rv_RV[l_i].r_open_max;			//Angepasst an Ventilstellung [MaxOut = 100 -> Ventil zu 100% geöffnet]
		
		//Übertragung der PID-Regelparameter an PID Funktionsbaustein
		FB_PID[l_i].PIDParameters.Gain := l_r_pid_var[l_i,0];
		FB_PID[l_i].PIDParameters.IntegrationTime := l_r_pid_var[l_i,1];
		FB_PID[l_i].PIDParameters.DerivativeTime := l_r_pid_var[l_i,2];
		FB_PID[l_i].PIDParameters.FilterTime := l_r_pid_var[l_i,3];
		FB_PID[l_i].MinOut:= l_r_pid_var[l_i,4]; 	
		FB_PID[l_i].MaxOut:= l_r_pid_var[l_i,5];
		
		//Initialisierung der Grenzen für PID-Ausgangsgrößen während Tuning
		FB_OscillationTuning[l_i].MinOut:= l_r_pid_var[l_i,4];	
		FB_OscillationTuning[l_i].MaxOut:= l_r_pid_var[l_i,5];
		
		//Initialisierung Rampenparameter
		FB_Limiter[l_i].MaxPosSlewRate := l_r_ramp_var[l_i,0];
		FB_Limiter[l_i].MaxNegSlewRate := l_r_ramp_var[l_i,1];
		FB_Limiter[l_i].MinOut := l_r_ramp_var[l_i,2];
		FB_Limiter[l_i].MaxOut := l_r_ramp_var[l_i,3];						
	 
		//Initialstatus: AUS
		g_i_status_PIRC[l_i] := 0;
	ENDLOOP
	
	LOOP l_i = 3 TO 4 DO
		//Initialisierung Rampenparameter für kontrolliertes Öffnen der Ventile
		FB_Limiter[l_i].MaxPosSlewRate := l_r_ramp_var[l_i,0];
		FB_Limiter[l_i].MaxNegSlewRate := l_r_ramp_var[l_i,1];
		FB_Limiter[l_i].MinOut := l_r_ramp_var[l_i,2];
		FB_Limiter[l_i].MaxOut := l_r_ramp_var[l_i,3];	
	ENDLOOP
	L_R_test := 0;
END_PROGRAM



PROGRAM _CYCLIC	
	LOOP l_i = 1 TO 2 DO
		CASE g_i_status_PIRC[l_i] OF
			ACTION 0:	//Druckregelung AUS
				FB_PID[l_i].Enable := FALSE;
				FB_OscillationTuning[l_i].Enable := FALSE;
				g_b_ramp_active[l_i] := FALSE;
				g_rv_RV[l_i].i_ao := INT(G_R_ANALOG_SIGNAL);
			ENDACTION
			
			ACTION 1:	//Druckregelung AN
				//Manuelle Anpassung der minimalen und maximalen Ventilstellung (Visualisierung)
				IF EDGEPOS(g_rv_RV[l_i].b_update) THEN
					l_r_pid_var[l_i,4] := g_rv_RV[l_i].r_open_min;			//Angepasst an Ventilstellung [MinOut = 0 -> Ventil zu 0% geöffnet]
					l_r_pid_var[l_i,5] := g_rv_RV[l_i].r_open_max;			//Angepasst an Ventilstellung [MaxOut = 100 -> Ventil zu 100% geöffnet]
					FB_PID[l_i].MaxOut:= 100 - l_r_pid_var[l_i,4]; 	
					FB_PID[l_i].MinOut:= 100 - l_r_pid_var[l_i,5];
					FB_PID[l_i].Update := TRUE;
				ELSE
					IF EDGEPOS(FB_PID[l_i].UpdateDone) THEN
						FB_PID[l_i].Update := FALSE;
						g_rv_RV[l_i].b_update := FALSE;
					ENDIF
				ENDIF
				
				//Manuelle Anpassung des Druckniveaus über Rampe (Visualisierung)
				IF EDGEPOS(g_b_ramp_active[l_i]) THEN
					FB_Limiter[l_i].OutPresetValue := g_pres_PIRC[l_i].r_ist;   		//Start bei aktuellem Druckwert
					FB_Limiter[l_i].SetOut := TRUE;
					IF g_r_ramp_time[l_i] <> 0 THEN										//Teilen durch Null führt funktionsintern zu Fehler
						FB_Limiter[l_i].MaxPosSlewRate := ABS(g_pres_PIRC[l_i].r_soll - g_pres_PIRC[l_i].r_ist) / (g_r_ramp_time[l_i] * 60);	//Steigung berechnen 
						FB_Limiter[l_i].MaxNegSlewRate := ABS(g_pres_PIRC[l_i].r_soll - g_pres_PIRC[l_i].r_ist) / (g_r_ramp_time[l_i] * 60);							
					ELSE
						FB_Limiter[l_i].MaxPosSlewRate := 2;	//Steigung berechnen 
						FB_Limiter[l_i].MaxNegSlewRate := 2;							
					ENDIF
					FB_Limiter[l_i].Update := TRUE;
				ELSE
					IF EDGEPOS(FB_Limiter[l_i].UpdateDone) THEN
						FB_Limiter[l_i].Update := FALSE;
					ENDIF
				ENDIF
				
				//Rampe starten
				IF g_b_ramp_active[l_i] = TRUE THEN
					FB_Limiter[l_i].Enable := TRUE;
					FB_Limiter[l_i].In := g_pres_PIRC[l_i].r_soll;
					FB_Limiter[l_i] FUB MTBasicsLimiter();
					g_r_p_soll_PIRC[l_i] := FB_Limiter[l_i].Out;
				ELSE
					FB_Limiter[l_i].Enable := FALSE;
				ENDIF					
				
				//Sobald Zielwert der Rampe erreicht wird, Rampe beenden
				IF g_pres_PIRC[l_i].r_soll = g_r_p_soll_PIRC[l_i] THEN
					g_b_ramp_active[l_i] := FALSE;
				ENDIF
				
				//PID-Regelung ausführen
				FB_PID[l_i].Enable := TRUE;													//Regler aktivieren
				FB_PID[l_i].SetValue := g_r_p_soll_PIRC[l_i]; 								//Sollwert setzen
				FB_PID[l_i].ActValue := g_pres_PIRC[l_i].r_ist;								//Istwert einlesen
				FB_PID[l_i] FUB MTBasicsPID();												//Funktionsaufruf MTBasicsPID 
				// Falls g_r_p_soll_PIRC[l_i] > g_pres_PIRC[l_i].r_ist -> FB_PID[l_i].Out = 100 (Ventil geschlossen)
				// Falls g_r_p_soll_PIRC[l_i] < g_pres_PIRC[l_i].r_ist -> FB_PID[l_i].Out = 0	(Ventil offen)
				l_r_pid_out[l_i] := g_rv_RV[l_i].r_open_max - FB_PID[l_i].Out; 					//FB_PID[l_i].Out mit negativer Rückkopplung von Stell- und Regelgröße
							
				//Übertragung der PID-Ausgabewerte an die Ventilstellung (Geschlossen -> Offen: i_ao = 6554 -> 32767 / l_r_pid_out = 0 -> 100)
				IF l_i = 1 THEN			//Unterscheidung: i_ao bei Dampf bei höherem 4mA-Signal
					g_rv_RV[l_i].i_ao := INT((l_r_pid_out[l_i] * (G_R_ANALOG_SIGNAL - G_R_ANALOG_SIGNAL_4mA[6]) / (g_rv_RV[l_i].r_open_max-g_rv_RV[l_i].r_open_min)) + G_R_ANALOG_SIGNAL_4mA[6]);
				ELSE
					g_rv_RV[l_i].i_ao := INT((l_r_pid_out[l_i] * (G_R_ANALOG_SIGNAL*16/20) / (g_rv_RV[l_i].r_open_max-g_rv_RV[l_i].r_open_min)) + G_R_ANALOG_SIGNAL*4/20);
				ENDIF
				IF g_rv_RV[l_i].i_ao >= INT(G_R_ANALOG_SIGNAL) THEN			//Sicherung bei Rundungsfehlern
					g_rv_RV[l_i].i_ao := INT(G_R_ANALOG_SIGNAL);
				ELSE
					IF g_rv_RV[l_i].i_ao <= INT(G_R_ANALOG_SIGNAL*4/20) THEN
						g_rv_RV[l_i].i_ao := INT(G_R_ANALOG_SIGNAL*4/20);
					ENDIF
				ENDIF
			ENDACTION
				
			ACTION 2: 	//Langsames Öffnen der Ventile für kontrollierten Druckabbau
				FB_PID[l_i].Enable := FALSE;
				FB_OscillationTuning[l_i].Enable := FALSE;
				g_rv_RV[l_i].b_update := FALSE;
				g_pres_PIRC[l_i].r_soll := 0;				//Soll-Druck zu Null
				g_r_p_soll_PIRC[l_i] := 0;
				g_b_ramp_active[l_i] := FALSE;
				//Kontrolliertes Öffnen des Ventils
				FB_Limiter[l_i+2].OutPresetValue := 40;
				FB_Limiter[l_i+2].SetOut := TRUE;
				FB_Limiter[l_i+2].Enable := TRUE;
				FB_Limiter[l_i+2].In := 100;
				FB_Limiter[l_i+2] FUB MTBasicsLimiter();
				//Übertragung der Ausgabewerte an die Ventilstellung
				g_rv_RV[l_i].i_ao := INT((FB_Limiter[l_i+2].Out * (G_R_ANALOG_SIGNAL*16/20) / (g_rv_RV[l_i].r_open_max-g_rv_RV[l_i].r_open_min)) + G_R_ANALOG_SIGNAL*4/20);
				IF g_rv_RV[l_i].i_ao >= INT(G_R_ANALOG_SIGNAL) THEN			//Sicherung bei Rundungsfehlern
					g_rv_RV[l_i].i_ao := INT(G_R_ANALOG_SIGNAL);
				ELSE
					IF g_rv_RV[l_i].i_ao <= INT(G_R_ANALOG_SIGNAL*4/20) THEN
						g_rv_RV[l_i].i_ao := INT(G_R_ANALOG_SIGNAL*4/20);
					ENDIF
				ENDIF
			ENDACTION
    
			ELSEACTION:	//Fehler: Kein definierter Status
				g_b_error[l_i+54] := TRUE;
				g_rv_RV[l_i].i_ao := INT(G_R_ANALOG_SIGNAL*4/20);	//Prozessregelventile offen
			ENDACTION
		ENDCASE
	ENDLOOP	 
END_PROGRAM

PROGRAM _EXIT
	(* Insert code here *)
	 
END_PROGRAM